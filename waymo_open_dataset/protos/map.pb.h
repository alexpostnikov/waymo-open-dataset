// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: waymo_open_dataset/protos/map.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
namespace waymo {
namespace open_dataset {
class BoundarySegment;
class BoundarySegmentDefaultTypeInternal;
extern BoundarySegmentDefaultTypeInternal _BoundarySegment_default_instance_;
class Crosswalk;
class CrosswalkDefaultTypeInternal;
extern CrosswalkDefaultTypeInternal _Crosswalk_default_instance_;
class DynamicState;
class DynamicStateDefaultTypeInternal;
extern DynamicStateDefaultTypeInternal _DynamicState_default_instance_;
class LaneCenter;
class LaneCenterDefaultTypeInternal;
extern LaneCenterDefaultTypeInternal _LaneCenter_default_instance_;
class LaneNeighbor;
class LaneNeighborDefaultTypeInternal;
extern LaneNeighborDefaultTypeInternal _LaneNeighbor_default_instance_;
class Map;
class MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class MapFeature;
class MapFeatureDefaultTypeInternal;
extern MapFeatureDefaultTypeInternal _MapFeature_default_instance_;
class MapPoint;
class MapPointDefaultTypeInternal;
extern MapPointDefaultTypeInternal _MapPoint_default_instance_;
class RoadEdge;
class RoadEdgeDefaultTypeInternal;
extern RoadEdgeDefaultTypeInternal _RoadEdge_default_instance_;
class RoadLine;
class RoadLineDefaultTypeInternal;
extern RoadLineDefaultTypeInternal _RoadLine_default_instance_;
class SpeedBump;
class SpeedBumpDefaultTypeInternal;
extern SpeedBumpDefaultTypeInternal _SpeedBump_default_instance_;
class StopSign;
class StopSignDefaultTypeInternal;
extern StopSignDefaultTypeInternal _StopSign_default_instance_;
class TrafficSignalLaneState;
class TrafficSignalLaneStateDefaultTypeInternal;
extern TrafficSignalLaneStateDefaultTypeInternal _TrafficSignalLaneState_default_instance_;
}  // namespace open_dataset
}  // namespace waymo
PROTOBUF_NAMESPACE_OPEN
template<> ::waymo::open_dataset::BoundarySegment* Arena::CreateMaybeMessage<::waymo::open_dataset::BoundarySegment>(Arena*);
template<> ::waymo::open_dataset::Crosswalk* Arena::CreateMaybeMessage<::waymo::open_dataset::Crosswalk>(Arena*);
template<> ::waymo::open_dataset::DynamicState* Arena::CreateMaybeMessage<::waymo::open_dataset::DynamicState>(Arena*);
template<> ::waymo::open_dataset::LaneCenter* Arena::CreateMaybeMessage<::waymo::open_dataset::LaneCenter>(Arena*);
template<> ::waymo::open_dataset::LaneNeighbor* Arena::CreateMaybeMessage<::waymo::open_dataset::LaneNeighbor>(Arena*);
template<> ::waymo::open_dataset::Map* Arena::CreateMaybeMessage<::waymo::open_dataset::Map>(Arena*);
template<> ::waymo::open_dataset::MapFeature* Arena::CreateMaybeMessage<::waymo::open_dataset::MapFeature>(Arena*);
template<> ::waymo::open_dataset::MapPoint* Arena::CreateMaybeMessage<::waymo::open_dataset::MapPoint>(Arena*);
template<> ::waymo::open_dataset::RoadEdge* Arena::CreateMaybeMessage<::waymo::open_dataset::RoadEdge>(Arena*);
template<> ::waymo::open_dataset::RoadLine* Arena::CreateMaybeMessage<::waymo::open_dataset::RoadLine>(Arena*);
template<> ::waymo::open_dataset::SpeedBump* Arena::CreateMaybeMessage<::waymo::open_dataset::SpeedBump>(Arena*);
template<> ::waymo::open_dataset::StopSign* Arena::CreateMaybeMessage<::waymo::open_dataset::StopSign>(Arena*);
template<> ::waymo::open_dataset::TrafficSignalLaneState* Arena::CreateMaybeMessage<::waymo::open_dataset::TrafficSignalLaneState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace waymo {
namespace open_dataset {

enum TrafficSignalLaneState_State : int {
  TrafficSignalLaneState_State_LANE_STATE_UNKNOWN = 0,
  TrafficSignalLaneState_State_LANE_STATE_ARROW_STOP = 1,
  TrafficSignalLaneState_State_LANE_STATE_ARROW_CAUTION = 2,
  TrafficSignalLaneState_State_LANE_STATE_ARROW_GO = 3,
  TrafficSignalLaneState_State_LANE_STATE_STOP = 4,
  TrafficSignalLaneState_State_LANE_STATE_CAUTION = 5,
  TrafficSignalLaneState_State_LANE_STATE_GO = 6,
  TrafficSignalLaneState_State_LANE_STATE_FLASHING_STOP = 7,
  TrafficSignalLaneState_State_LANE_STATE_FLASHING_CAUTION = 8
};
bool TrafficSignalLaneState_State_IsValid(int value);
constexpr TrafficSignalLaneState_State TrafficSignalLaneState_State_State_MIN = TrafficSignalLaneState_State_LANE_STATE_UNKNOWN;
constexpr TrafficSignalLaneState_State TrafficSignalLaneState_State_State_MAX = TrafficSignalLaneState_State_LANE_STATE_FLASHING_CAUTION;
constexpr int TrafficSignalLaneState_State_State_ARRAYSIZE = TrafficSignalLaneState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSignalLaneState_State_descriptor();
template<typename T>
inline const std::string& TrafficSignalLaneState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSignalLaneState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSignalLaneState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSignalLaneState_State_descriptor(), enum_t_value);
}
inline bool TrafficSignalLaneState_State_Parse(
    const std::string& name, TrafficSignalLaneState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSignalLaneState_State>(
    TrafficSignalLaneState_State_descriptor(), name, value);
}
enum LaneCenter_LaneType : int {
  LaneCenter_LaneType_TYPE_UNDEFINED = 0,
  LaneCenter_LaneType_TYPE_FREEWAY = 1,
  LaneCenter_LaneType_TYPE_SURFACE_STREET = 2,
  LaneCenter_LaneType_TYPE_BIKE_LANE = 3
};
bool LaneCenter_LaneType_IsValid(int value);
constexpr LaneCenter_LaneType LaneCenter_LaneType_LaneType_MIN = LaneCenter_LaneType_TYPE_UNDEFINED;
constexpr LaneCenter_LaneType LaneCenter_LaneType_LaneType_MAX = LaneCenter_LaneType_TYPE_BIKE_LANE;
constexpr int LaneCenter_LaneType_LaneType_ARRAYSIZE = LaneCenter_LaneType_LaneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneCenter_LaneType_descriptor();
template<typename T>
inline const std::string& LaneCenter_LaneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneCenter_LaneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneCenter_LaneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneCenter_LaneType_descriptor(), enum_t_value);
}
inline bool LaneCenter_LaneType_Parse(
    const std::string& name, LaneCenter_LaneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneCenter_LaneType>(
    LaneCenter_LaneType_descriptor(), name, value);
}
enum RoadEdge_RoadEdgeType : int {
  RoadEdge_RoadEdgeType_TYPE_UNKNOWN = 0,
  RoadEdge_RoadEdgeType_TYPE_ROAD_EDGE_BOUNDARY = 1,
  RoadEdge_RoadEdgeType_TYPE_ROAD_EDGE_MEDIAN = 2
};
bool RoadEdge_RoadEdgeType_IsValid(int value);
constexpr RoadEdge_RoadEdgeType RoadEdge_RoadEdgeType_RoadEdgeType_MIN = RoadEdge_RoadEdgeType_TYPE_UNKNOWN;
constexpr RoadEdge_RoadEdgeType RoadEdge_RoadEdgeType_RoadEdgeType_MAX = RoadEdge_RoadEdgeType_TYPE_ROAD_EDGE_MEDIAN;
constexpr int RoadEdge_RoadEdgeType_RoadEdgeType_ARRAYSIZE = RoadEdge_RoadEdgeType_RoadEdgeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoadEdge_RoadEdgeType_descriptor();
template<typename T>
inline const std::string& RoadEdge_RoadEdgeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadEdge_RoadEdgeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadEdge_RoadEdgeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoadEdge_RoadEdgeType_descriptor(), enum_t_value);
}
inline bool RoadEdge_RoadEdgeType_Parse(
    const std::string& name, RoadEdge_RoadEdgeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoadEdge_RoadEdgeType>(
    RoadEdge_RoadEdgeType_descriptor(), name, value);
}
enum RoadLine_RoadLineType : int {
  RoadLine_RoadLineType_TYPE_UNKNOWN = 0,
  RoadLine_RoadLineType_TYPE_BROKEN_SINGLE_WHITE = 1,
  RoadLine_RoadLineType_TYPE_SOLID_SINGLE_WHITE = 2,
  RoadLine_RoadLineType_TYPE_SOLID_DOUBLE_WHITE = 3,
  RoadLine_RoadLineType_TYPE_BROKEN_SINGLE_YELLOW = 4,
  RoadLine_RoadLineType_TYPE_BROKEN_DOUBLE_YELLOW = 5,
  RoadLine_RoadLineType_TYPE_SOLID_SINGLE_YELLOW = 6,
  RoadLine_RoadLineType_TYPE_SOLID_DOUBLE_YELLOW = 7,
  RoadLine_RoadLineType_TYPE_PASSING_DOUBLE_YELLOW = 8
};
bool RoadLine_RoadLineType_IsValid(int value);
constexpr RoadLine_RoadLineType RoadLine_RoadLineType_RoadLineType_MIN = RoadLine_RoadLineType_TYPE_UNKNOWN;
constexpr RoadLine_RoadLineType RoadLine_RoadLineType_RoadLineType_MAX = RoadLine_RoadLineType_TYPE_PASSING_DOUBLE_YELLOW;
constexpr int RoadLine_RoadLineType_RoadLineType_ARRAYSIZE = RoadLine_RoadLineType_RoadLineType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoadLine_RoadLineType_descriptor();
template<typename T>
inline const std::string& RoadLine_RoadLineType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadLine_RoadLineType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadLine_RoadLineType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoadLine_RoadLineType_descriptor(), enum_t_value);
}
inline bool RoadLine_RoadLineType_Parse(
    const std::string& name, RoadLine_RoadLineType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoadLine_RoadLineType>(
    RoadLine_RoadLineType_descriptor(), name, value);
}
// ===================================================================

class Map :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.Map) */ {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);
  Map(Map&& from) noexcept
    : Map() {
    *this = ::std::move(from);
  }

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map& operator=(Map&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Map& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
               &_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Map& a, Map& b) {
    a.Swap(&b);
  }
  inline void Swap(Map* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Map* New() const final {
    return CreateMaybeMessage<Map>(nullptr);
  }

  Map* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Map>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.Map";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapFeaturesFieldNumber = 1,
    kDynamicStatesFieldNumber = 2,
  };
  // repeated .waymo.open_dataset.MapFeature map_features = 1;
  int map_features_size() const;
  void clear_map_features();
  ::waymo::open_dataset::MapFeature* mutable_map_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapFeature >*
      mutable_map_features();
  const ::waymo::open_dataset::MapFeature& map_features(int index) const;
  ::waymo::open_dataset::MapFeature* add_map_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapFeature >&
      map_features() const;

  // repeated .waymo.open_dataset.DynamicState dynamic_states = 2;
  int dynamic_states_size() const;
  void clear_dynamic_states();
  ::waymo::open_dataset::DynamicState* mutable_dynamic_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::DynamicState >*
      mutable_dynamic_states();
  const ::waymo::open_dataset::DynamicState& dynamic_states(int index) const;
  ::waymo::open_dataset::DynamicState* add_dynamic_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::DynamicState >&
      dynamic_states() const;

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.Map)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapFeature > map_features_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::DynamicState > dynamic_states_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class DynamicState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.DynamicState) */ {
 public:
  DynamicState();
  virtual ~DynamicState();

  DynamicState(const DynamicState& from);
  DynamicState(DynamicState&& from) noexcept
    : DynamicState() {
    *this = ::std::move(from);
  }

  inline DynamicState& operator=(const DynamicState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicState& operator=(DynamicState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DynamicState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicState* internal_default_instance() {
    return reinterpret_cast<const DynamicState*>(
               &_DynamicState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DynamicState& a, DynamicState& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DynamicState* New() const final {
    return CreateMaybeMessage<DynamicState>(nullptr);
  }

  DynamicState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DynamicState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DynamicState& from);
  void MergeFrom(const DynamicState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.DynamicState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneStatesFieldNumber = 2,
    kTimestampSecondsFieldNumber = 1,
  };
  // repeated .waymo.open_dataset.TrafficSignalLaneState lane_states = 2;
  int lane_states_size() const;
  void clear_lane_states();
  ::waymo::open_dataset::TrafficSignalLaneState* mutable_lane_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::TrafficSignalLaneState >*
      mutable_lane_states();
  const ::waymo::open_dataset::TrafficSignalLaneState& lane_states(int index) const;
  ::waymo::open_dataset::TrafficSignalLaneState* add_lane_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::TrafficSignalLaneState >&
      lane_states() const;

  // optional double timestamp_seconds = 1;
  bool has_timestamp_seconds() const;
  void clear_timestamp_seconds();
  double timestamp_seconds() const;
  void set_timestamp_seconds(double value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.DynamicState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::TrafficSignalLaneState > lane_states_;
  double timestamp_seconds_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class TrafficSignalLaneState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.TrafficSignalLaneState) */ {
 public:
  TrafficSignalLaneState();
  virtual ~TrafficSignalLaneState();

  TrafficSignalLaneState(const TrafficSignalLaneState& from);
  TrafficSignalLaneState(TrafficSignalLaneState&& from) noexcept
    : TrafficSignalLaneState() {
    *this = ::std::move(from);
  }

  inline TrafficSignalLaneState& operator=(const TrafficSignalLaneState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSignalLaneState& operator=(TrafficSignalLaneState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSignalLaneState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignalLaneState* internal_default_instance() {
    return reinterpret_cast<const TrafficSignalLaneState*>(
               &_TrafficSignalLaneState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TrafficSignalLaneState& a, TrafficSignalLaneState& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSignalLaneState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignalLaneState* New() const final {
    return CreateMaybeMessage<TrafficSignalLaneState>(nullptr);
  }

  TrafficSignalLaneState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSignalLaneState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSignalLaneState& from);
  void MergeFrom(const TrafficSignalLaneState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSignalLaneState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.TrafficSignalLaneState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSignalLaneState_State State;
  static constexpr State LANE_STATE_UNKNOWN =
    TrafficSignalLaneState_State_LANE_STATE_UNKNOWN;
  static constexpr State LANE_STATE_ARROW_STOP =
    TrafficSignalLaneState_State_LANE_STATE_ARROW_STOP;
  static constexpr State LANE_STATE_ARROW_CAUTION =
    TrafficSignalLaneState_State_LANE_STATE_ARROW_CAUTION;
  static constexpr State LANE_STATE_ARROW_GO =
    TrafficSignalLaneState_State_LANE_STATE_ARROW_GO;
  static constexpr State LANE_STATE_STOP =
    TrafficSignalLaneState_State_LANE_STATE_STOP;
  static constexpr State LANE_STATE_CAUTION =
    TrafficSignalLaneState_State_LANE_STATE_CAUTION;
  static constexpr State LANE_STATE_GO =
    TrafficSignalLaneState_State_LANE_STATE_GO;
  static constexpr State LANE_STATE_FLASHING_STOP =
    TrafficSignalLaneState_State_LANE_STATE_FLASHING_STOP;
  static constexpr State LANE_STATE_FLASHING_CAUTION =
    TrafficSignalLaneState_State_LANE_STATE_FLASHING_CAUTION;
  static inline bool State_IsValid(int value) {
    return TrafficSignalLaneState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TrafficSignalLaneState_State_State_MIN;
  static constexpr State State_MAX =
    TrafficSignalLaneState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TrafficSignalLaneState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TrafficSignalLaneState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TrafficSignalLaneState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return TrafficSignalLaneState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopPointFieldNumber = 3,
    kLaneFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // optional .waymo.open_dataset.MapPoint stop_point = 3;
  bool has_stop_point() const;
  void clear_stop_point();
  const ::waymo::open_dataset::MapPoint& stop_point() const;
  ::waymo::open_dataset::MapPoint* release_stop_point();
  ::waymo::open_dataset::MapPoint* mutable_stop_point();
  void set_allocated_stop_point(::waymo::open_dataset::MapPoint* stop_point);

  // optional int64 lane = 1;
  bool has_lane() const;
  void clear_lane();
  ::PROTOBUF_NAMESPACE_ID::int64 lane() const;
  void set_lane(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .waymo.open_dataset.TrafficSignalLaneState.State state = 2;
  bool has_state() const;
  void clear_state();
  ::waymo::open_dataset::TrafficSignalLaneState_State state() const;
  void set_state(::waymo::open_dataset::TrafficSignalLaneState_State value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.TrafficSignalLaneState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::waymo::open_dataset::MapPoint* stop_point_;
  ::PROTOBUF_NAMESPACE_ID::int64 lane_;
  int state_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class MapFeature :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.MapFeature) */ {
 public:
  MapFeature();
  virtual ~MapFeature();

  MapFeature(const MapFeature& from);
  MapFeature(MapFeature&& from) noexcept
    : MapFeature() {
    *this = ::std::move(from);
  }

  inline MapFeature& operator=(const MapFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapFeature& operator=(MapFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapFeature& default_instance();

  enum FeatureDataCase {
    kLane = 3,
    kRoadLine = 4,
    kRoadEdge = 5,
    kStopSign = 7,
    kCrosswalk = 8,
    kSpeedBump = 9,
    FEATURE_DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapFeature* internal_default_instance() {
    return reinterpret_cast<const MapFeature*>(
               &_MapFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MapFeature& a, MapFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(MapFeature* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapFeature* New() const final {
    return CreateMaybeMessage<MapFeature>(nullptr);
  }

  MapFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapFeature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapFeature& from);
  void MergeFrom(const MapFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapFeature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.MapFeature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLaneFieldNumber = 3,
    kRoadLineFieldNumber = 4,
    kRoadEdgeFieldNumber = 5,
    kStopSignFieldNumber = 7,
    kCrosswalkFieldNumber = 8,
    kSpeedBumpFieldNumber = 9,
  };
  // optional int64 id = 1;
  bool has_id() const;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .waymo.open_dataset.LaneCenter lane = 3;
  bool has_lane() const;
  void clear_lane();
  const ::waymo::open_dataset::LaneCenter& lane() const;
  ::waymo::open_dataset::LaneCenter* release_lane();
  ::waymo::open_dataset::LaneCenter* mutable_lane();
  void set_allocated_lane(::waymo::open_dataset::LaneCenter* lane);

  // optional .waymo.open_dataset.RoadLine road_line = 4;
  bool has_road_line() const;
  void clear_road_line();
  const ::waymo::open_dataset::RoadLine& road_line() const;
  ::waymo::open_dataset::RoadLine* release_road_line();
  ::waymo::open_dataset::RoadLine* mutable_road_line();
  void set_allocated_road_line(::waymo::open_dataset::RoadLine* road_line);

  // optional .waymo.open_dataset.RoadEdge road_edge = 5;
  bool has_road_edge() const;
  void clear_road_edge();
  const ::waymo::open_dataset::RoadEdge& road_edge() const;
  ::waymo::open_dataset::RoadEdge* release_road_edge();
  ::waymo::open_dataset::RoadEdge* mutable_road_edge();
  void set_allocated_road_edge(::waymo::open_dataset::RoadEdge* road_edge);

  // optional .waymo.open_dataset.StopSign stop_sign = 7;
  bool has_stop_sign() const;
  void clear_stop_sign();
  const ::waymo::open_dataset::StopSign& stop_sign() const;
  ::waymo::open_dataset::StopSign* release_stop_sign();
  ::waymo::open_dataset::StopSign* mutable_stop_sign();
  void set_allocated_stop_sign(::waymo::open_dataset::StopSign* stop_sign);

  // optional .waymo.open_dataset.Crosswalk crosswalk = 8;
  bool has_crosswalk() const;
  void clear_crosswalk();
  const ::waymo::open_dataset::Crosswalk& crosswalk() const;
  ::waymo::open_dataset::Crosswalk* release_crosswalk();
  ::waymo::open_dataset::Crosswalk* mutable_crosswalk();
  void set_allocated_crosswalk(::waymo::open_dataset::Crosswalk* crosswalk);

  // optional .waymo.open_dataset.SpeedBump speed_bump = 9;
  bool has_speed_bump() const;
  void clear_speed_bump();
  const ::waymo::open_dataset::SpeedBump& speed_bump() const;
  ::waymo::open_dataset::SpeedBump* release_speed_bump();
  ::waymo::open_dataset::SpeedBump* mutable_speed_bump();
  void set_allocated_speed_bump(::waymo::open_dataset::SpeedBump* speed_bump);

  void clear_feature_data();
  FeatureDataCase feature_data_case() const;
  // @@protoc_insertion_point(class_scope:waymo.open_dataset.MapFeature)
 private:
  class _Internal;
  void set_has_lane();
  void set_has_road_line();
  void set_has_road_edge();
  void set_has_stop_sign();
  void set_has_crosswalk();
  void set_has_speed_bump();

  inline bool has_feature_data() const;
  inline void clear_has_feature_data();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  union FeatureDataUnion {
    FeatureDataUnion() {}
    ::waymo::open_dataset::LaneCenter* lane_;
    ::waymo::open_dataset::RoadLine* road_line_;
    ::waymo::open_dataset::RoadEdge* road_edge_;
    ::waymo::open_dataset::StopSign* stop_sign_;
    ::waymo::open_dataset::Crosswalk* crosswalk_;
    ::waymo::open_dataset::SpeedBump* speed_bump_;
  } feature_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class MapPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.MapPoint) */ {
 public:
  MapPoint();
  virtual ~MapPoint();

  MapPoint(const MapPoint& from);
  MapPoint(MapPoint&& from) noexcept
    : MapPoint() {
    *this = ::std::move(from);
  }

  inline MapPoint& operator=(const MapPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapPoint& operator=(MapPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapPoint* internal_default_instance() {
    return reinterpret_cast<const MapPoint*>(
               &_MapPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MapPoint& a, MapPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MapPoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapPoint* New() const final {
    return CreateMaybeMessage<MapPoint>(nullptr);
  }

  MapPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapPoint& from);
  void MergeFrom(const MapPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.MapPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.MapPoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class BoundarySegment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.BoundarySegment) */ {
 public:
  BoundarySegment();
  virtual ~BoundarySegment();

  BoundarySegment(const BoundarySegment& from);
  BoundarySegment(BoundarySegment&& from) noexcept
    : BoundarySegment() {
    *this = ::std::move(from);
  }

  inline BoundarySegment& operator=(const BoundarySegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundarySegment& operator=(BoundarySegment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundarySegment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundarySegment* internal_default_instance() {
    return reinterpret_cast<const BoundarySegment*>(
               &_BoundarySegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BoundarySegment& a, BoundarySegment& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundarySegment* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundarySegment* New() const final {
    return CreateMaybeMessage<BoundarySegment>(nullptr);
  }

  BoundarySegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundarySegment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundarySegment& from);
  void MergeFrom(const BoundarySegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundarySegment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.BoundarySegment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneStartIndexFieldNumber = 1,
    kLaneEndIndexFieldNumber = 2,
    kBoundaryFeatureIdFieldNumber = 3,
    kBoundaryTypeFieldNumber = 4,
  };
  // optional int32 lane_start_index = 1;
  bool has_lane_start_index() const;
  void clear_lane_start_index();
  ::PROTOBUF_NAMESPACE_ID::int32 lane_start_index() const;
  void set_lane_start_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 lane_end_index = 2;
  bool has_lane_end_index() const;
  void clear_lane_end_index();
  ::PROTOBUF_NAMESPACE_ID::int32 lane_end_index() const;
  void set_lane_end_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 boundary_feature_id = 3;
  bool has_boundary_feature_id() const;
  void clear_boundary_feature_id();
  ::PROTOBUF_NAMESPACE_ID::int64 boundary_feature_id() const;
  void set_boundary_feature_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .waymo.open_dataset.RoadLine.RoadLineType boundary_type = 4;
  bool has_boundary_type() const;
  void clear_boundary_type();
  ::waymo::open_dataset::RoadLine_RoadLineType boundary_type() const;
  void set_boundary_type(::waymo::open_dataset::RoadLine_RoadLineType value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.BoundarySegment)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 lane_start_index_;
  ::PROTOBUF_NAMESPACE_ID::int32 lane_end_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 boundary_feature_id_;
  int boundary_type_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class LaneNeighbor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.LaneNeighbor) */ {
 public:
  LaneNeighbor();
  virtual ~LaneNeighbor();

  LaneNeighbor(const LaneNeighbor& from);
  LaneNeighbor(LaneNeighbor&& from) noexcept
    : LaneNeighbor() {
    *this = ::std::move(from);
  }

  inline LaneNeighbor& operator=(const LaneNeighbor& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneNeighbor& operator=(LaneNeighbor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneNeighbor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneNeighbor* internal_default_instance() {
    return reinterpret_cast<const LaneNeighbor*>(
               &_LaneNeighbor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LaneNeighbor& a, LaneNeighbor& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneNeighbor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneNeighbor* New() const final {
    return CreateMaybeMessage<LaneNeighbor>(nullptr);
  }

  LaneNeighbor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneNeighbor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneNeighbor& from);
  void MergeFrom(const LaneNeighbor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneNeighbor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.LaneNeighbor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundariesFieldNumber = 6,
    kFeatureIdFieldNumber = 1,
    kSelfStartIndexFieldNumber = 2,
    kSelfEndIndexFieldNumber = 3,
    kNeighborStartIndexFieldNumber = 4,
    kNeighborEndIndexFieldNumber = 5,
  };
  // repeated .waymo.open_dataset.BoundarySegment boundaries = 6;
  int boundaries_size() const;
  void clear_boundaries();
  ::waymo::open_dataset::BoundarySegment* mutable_boundaries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >*
      mutable_boundaries();
  const ::waymo::open_dataset::BoundarySegment& boundaries(int index) const;
  ::waymo::open_dataset::BoundarySegment* add_boundaries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >&
      boundaries() const;

  // optional int64 feature_id = 1;
  bool has_feature_id() const;
  void clear_feature_id();
  ::PROTOBUF_NAMESPACE_ID::int64 feature_id() const;
  void set_feature_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 self_start_index = 2;
  bool has_self_start_index() const;
  void clear_self_start_index();
  ::PROTOBUF_NAMESPACE_ID::int32 self_start_index() const;
  void set_self_start_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 self_end_index = 3;
  bool has_self_end_index() const;
  void clear_self_end_index();
  ::PROTOBUF_NAMESPACE_ID::int32 self_end_index() const;
  void set_self_end_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 neighbor_start_index = 4;
  bool has_neighbor_start_index() const;
  void clear_neighbor_start_index();
  ::PROTOBUF_NAMESPACE_ID::int32 neighbor_start_index() const;
  void set_neighbor_start_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 neighbor_end_index = 5;
  bool has_neighbor_end_index() const;
  void clear_neighbor_end_index();
  ::PROTOBUF_NAMESPACE_ID::int32 neighbor_end_index() const;
  void set_neighbor_end_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.LaneNeighbor)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment > boundaries_;
  ::PROTOBUF_NAMESPACE_ID::int64 feature_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 self_start_index_;
  ::PROTOBUF_NAMESPACE_ID::int32 self_end_index_;
  ::PROTOBUF_NAMESPACE_ID::int32 neighbor_start_index_;
  ::PROTOBUF_NAMESPACE_ID::int32 neighbor_end_index_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class LaneCenter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.LaneCenter) */ {
 public:
  LaneCenter();
  virtual ~LaneCenter();

  LaneCenter(const LaneCenter& from);
  LaneCenter(LaneCenter&& from) noexcept
    : LaneCenter() {
    *this = ::std::move(from);
  }

  inline LaneCenter& operator=(const LaneCenter& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneCenter& operator=(LaneCenter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneCenter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneCenter* internal_default_instance() {
    return reinterpret_cast<const LaneCenter*>(
               &_LaneCenter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LaneCenter& a, LaneCenter& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneCenter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneCenter* New() const final {
    return CreateMaybeMessage<LaneCenter>(nullptr);
  }

  LaneCenter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneCenter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneCenter& from);
  void MergeFrom(const LaneCenter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneCenter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.LaneCenter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LaneCenter_LaneType LaneType;
  static constexpr LaneType TYPE_UNDEFINED =
    LaneCenter_LaneType_TYPE_UNDEFINED;
  static constexpr LaneType TYPE_FREEWAY =
    LaneCenter_LaneType_TYPE_FREEWAY;
  static constexpr LaneType TYPE_SURFACE_STREET =
    LaneCenter_LaneType_TYPE_SURFACE_STREET;
  static constexpr LaneType TYPE_BIKE_LANE =
    LaneCenter_LaneType_TYPE_BIKE_LANE;
  static inline bool LaneType_IsValid(int value) {
    return LaneCenter_LaneType_IsValid(value);
  }
  static constexpr LaneType LaneType_MIN =
    LaneCenter_LaneType_LaneType_MIN;
  static constexpr LaneType LaneType_MAX =
    LaneCenter_LaneType_LaneType_MAX;
  static constexpr int LaneType_ARRAYSIZE =
    LaneCenter_LaneType_LaneType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneType_descriptor() {
    return LaneCenter_LaneType_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneType_Name.");
    return LaneCenter_LaneType_Name(enum_t_value);
  }
  static inline bool LaneType_Parse(const std::string& name,
      LaneType* value) {
    return LaneCenter_LaneType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPolylineFieldNumber = 8,
    kEntryLanesFieldNumber = 9,
    kExitLanesFieldNumber = 10,
    kLeftNeighborsFieldNumber = 11,
    kRightNeighborsFieldNumber = 12,
    kLeftBoundariesFieldNumber = 13,
    kRightBoundariesFieldNumber = 14,
    kSpeedLimitMphFieldNumber = 1,
    kTypeFieldNumber = 2,
    kInterpolatingFieldNumber = 3,
  };
  // repeated .waymo.open_dataset.MapPoint polyline = 8;
  int polyline_size() const;
  void clear_polyline();
  ::waymo::open_dataset::MapPoint* mutable_polyline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
      mutable_polyline();
  const ::waymo::open_dataset::MapPoint& polyline(int index) const;
  ::waymo::open_dataset::MapPoint* add_polyline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
      polyline() const;

  // repeated int64 entry_lanes = 9 [packed = true];
  int entry_lanes_size() const;
  void clear_entry_lanes();
  ::PROTOBUF_NAMESPACE_ID::int64 entry_lanes(int index) const;
  void set_entry_lanes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_entry_lanes(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      entry_lanes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_entry_lanes();

  // repeated int64 exit_lanes = 10 [packed = true];
  int exit_lanes_size() const;
  void clear_exit_lanes();
  ::PROTOBUF_NAMESPACE_ID::int64 exit_lanes(int index) const;
  void set_exit_lanes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_exit_lanes(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      exit_lanes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_exit_lanes();

  // repeated .waymo.open_dataset.LaneNeighbor left_neighbors = 11;
  int left_neighbors_size() const;
  void clear_left_neighbors();
  ::waymo::open_dataset::LaneNeighbor* mutable_left_neighbors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >*
      mutable_left_neighbors();
  const ::waymo::open_dataset::LaneNeighbor& left_neighbors(int index) const;
  ::waymo::open_dataset::LaneNeighbor* add_left_neighbors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >&
      left_neighbors() const;

  // repeated .waymo.open_dataset.LaneNeighbor right_neighbors = 12;
  int right_neighbors_size() const;
  void clear_right_neighbors();
  ::waymo::open_dataset::LaneNeighbor* mutable_right_neighbors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >*
      mutable_right_neighbors();
  const ::waymo::open_dataset::LaneNeighbor& right_neighbors(int index) const;
  ::waymo::open_dataset::LaneNeighbor* add_right_neighbors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >&
      right_neighbors() const;

  // repeated .waymo.open_dataset.BoundarySegment left_boundaries = 13;
  int left_boundaries_size() const;
  void clear_left_boundaries();
  ::waymo::open_dataset::BoundarySegment* mutable_left_boundaries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >*
      mutable_left_boundaries();
  const ::waymo::open_dataset::BoundarySegment& left_boundaries(int index) const;
  ::waymo::open_dataset::BoundarySegment* add_left_boundaries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >&
      left_boundaries() const;

  // repeated .waymo.open_dataset.BoundarySegment right_boundaries = 14;
  int right_boundaries_size() const;
  void clear_right_boundaries();
  ::waymo::open_dataset::BoundarySegment* mutable_right_boundaries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >*
      mutable_right_boundaries();
  const ::waymo::open_dataset::BoundarySegment& right_boundaries(int index) const;
  ::waymo::open_dataset::BoundarySegment* add_right_boundaries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >&
      right_boundaries() const;

  // optional double speed_limit_mph = 1;
  bool has_speed_limit_mph() const;
  void clear_speed_limit_mph();
  double speed_limit_mph() const;
  void set_speed_limit_mph(double value);

  // optional .waymo.open_dataset.LaneCenter.LaneType type = 2;
  bool has_type() const;
  void clear_type();
  ::waymo::open_dataset::LaneCenter_LaneType type() const;
  void set_type(::waymo::open_dataset::LaneCenter_LaneType value);

  // optional bool interpolating = 3;
  bool has_interpolating() const;
  void clear_interpolating();
  bool interpolating() const;
  void set_interpolating(bool value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.LaneCenter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint > polyline_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > entry_lanes_;
  mutable std::atomic<int> _entry_lanes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > exit_lanes_;
  mutable std::atomic<int> _exit_lanes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor > left_neighbors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor > right_neighbors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment > left_boundaries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment > right_boundaries_;
  double speed_limit_mph_;
  int type_;
  bool interpolating_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class RoadEdge :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.RoadEdge) */ {
 public:
  RoadEdge();
  virtual ~RoadEdge();

  RoadEdge(const RoadEdge& from);
  RoadEdge(RoadEdge&& from) noexcept
    : RoadEdge() {
    *this = ::std::move(from);
  }

  inline RoadEdge& operator=(const RoadEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadEdge& operator=(RoadEdge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoadEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadEdge* internal_default_instance() {
    return reinterpret_cast<const RoadEdge*>(
               &_RoadEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoadEdge& a, RoadEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadEdge* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoadEdge* New() const final {
    return CreateMaybeMessage<RoadEdge>(nullptr);
  }

  RoadEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoadEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoadEdge& from);
  void MergeFrom(const RoadEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.RoadEdge";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RoadEdge_RoadEdgeType RoadEdgeType;
  static constexpr RoadEdgeType TYPE_UNKNOWN =
    RoadEdge_RoadEdgeType_TYPE_UNKNOWN;
  static constexpr RoadEdgeType TYPE_ROAD_EDGE_BOUNDARY =
    RoadEdge_RoadEdgeType_TYPE_ROAD_EDGE_BOUNDARY;
  static constexpr RoadEdgeType TYPE_ROAD_EDGE_MEDIAN =
    RoadEdge_RoadEdgeType_TYPE_ROAD_EDGE_MEDIAN;
  static inline bool RoadEdgeType_IsValid(int value) {
    return RoadEdge_RoadEdgeType_IsValid(value);
  }
  static constexpr RoadEdgeType RoadEdgeType_MIN =
    RoadEdge_RoadEdgeType_RoadEdgeType_MIN;
  static constexpr RoadEdgeType RoadEdgeType_MAX =
    RoadEdge_RoadEdgeType_RoadEdgeType_MAX;
  static constexpr int RoadEdgeType_ARRAYSIZE =
    RoadEdge_RoadEdgeType_RoadEdgeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RoadEdgeType_descriptor() {
    return RoadEdge_RoadEdgeType_descriptor();
  }
  template<typename T>
  static inline const std::string& RoadEdgeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RoadEdgeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RoadEdgeType_Name.");
    return RoadEdge_RoadEdgeType_Name(enum_t_value);
  }
  static inline bool RoadEdgeType_Parse(const std::string& name,
      RoadEdgeType* value) {
    return RoadEdge_RoadEdgeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPolylineFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .waymo.open_dataset.MapPoint polyline = 2;
  int polyline_size() const;
  void clear_polyline();
  ::waymo::open_dataset::MapPoint* mutable_polyline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
      mutable_polyline();
  const ::waymo::open_dataset::MapPoint& polyline(int index) const;
  ::waymo::open_dataset::MapPoint* add_polyline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
      polyline() const;

  // optional .waymo.open_dataset.RoadEdge.RoadEdgeType type = 1;
  bool has_type() const;
  void clear_type();
  ::waymo::open_dataset::RoadEdge_RoadEdgeType type() const;
  void set_type(::waymo::open_dataset::RoadEdge_RoadEdgeType value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.RoadEdge)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint > polyline_;
  int type_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class RoadLine :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.RoadLine) */ {
 public:
  RoadLine();
  virtual ~RoadLine();

  RoadLine(const RoadLine& from);
  RoadLine(RoadLine&& from) noexcept
    : RoadLine() {
    *this = ::std::move(from);
  }

  inline RoadLine& operator=(const RoadLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadLine& operator=(RoadLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoadLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadLine* internal_default_instance() {
    return reinterpret_cast<const RoadLine*>(
               &_RoadLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoadLine& a, RoadLine& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadLine* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoadLine* New() const final {
    return CreateMaybeMessage<RoadLine>(nullptr);
  }

  RoadLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoadLine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoadLine& from);
  void MergeFrom(const RoadLine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.RoadLine";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RoadLine_RoadLineType RoadLineType;
  static constexpr RoadLineType TYPE_UNKNOWN =
    RoadLine_RoadLineType_TYPE_UNKNOWN;
  static constexpr RoadLineType TYPE_BROKEN_SINGLE_WHITE =
    RoadLine_RoadLineType_TYPE_BROKEN_SINGLE_WHITE;
  static constexpr RoadLineType TYPE_SOLID_SINGLE_WHITE =
    RoadLine_RoadLineType_TYPE_SOLID_SINGLE_WHITE;
  static constexpr RoadLineType TYPE_SOLID_DOUBLE_WHITE =
    RoadLine_RoadLineType_TYPE_SOLID_DOUBLE_WHITE;
  static constexpr RoadLineType TYPE_BROKEN_SINGLE_YELLOW =
    RoadLine_RoadLineType_TYPE_BROKEN_SINGLE_YELLOW;
  static constexpr RoadLineType TYPE_BROKEN_DOUBLE_YELLOW =
    RoadLine_RoadLineType_TYPE_BROKEN_DOUBLE_YELLOW;
  static constexpr RoadLineType TYPE_SOLID_SINGLE_YELLOW =
    RoadLine_RoadLineType_TYPE_SOLID_SINGLE_YELLOW;
  static constexpr RoadLineType TYPE_SOLID_DOUBLE_YELLOW =
    RoadLine_RoadLineType_TYPE_SOLID_DOUBLE_YELLOW;
  static constexpr RoadLineType TYPE_PASSING_DOUBLE_YELLOW =
    RoadLine_RoadLineType_TYPE_PASSING_DOUBLE_YELLOW;
  static inline bool RoadLineType_IsValid(int value) {
    return RoadLine_RoadLineType_IsValid(value);
  }
  static constexpr RoadLineType RoadLineType_MIN =
    RoadLine_RoadLineType_RoadLineType_MIN;
  static constexpr RoadLineType RoadLineType_MAX =
    RoadLine_RoadLineType_RoadLineType_MAX;
  static constexpr int RoadLineType_ARRAYSIZE =
    RoadLine_RoadLineType_RoadLineType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RoadLineType_descriptor() {
    return RoadLine_RoadLineType_descriptor();
  }
  template<typename T>
  static inline const std::string& RoadLineType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RoadLineType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RoadLineType_Name.");
    return RoadLine_RoadLineType_Name(enum_t_value);
  }
  static inline bool RoadLineType_Parse(const std::string& name,
      RoadLineType* value) {
    return RoadLine_RoadLineType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPolylineFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .waymo.open_dataset.MapPoint polyline = 2;
  int polyline_size() const;
  void clear_polyline();
  ::waymo::open_dataset::MapPoint* mutable_polyline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
      mutable_polyline();
  const ::waymo::open_dataset::MapPoint& polyline(int index) const;
  ::waymo::open_dataset::MapPoint* add_polyline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
      polyline() const;

  // optional .waymo.open_dataset.RoadLine.RoadLineType type = 1;
  bool has_type() const;
  void clear_type();
  ::waymo::open_dataset::RoadLine_RoadLineType type() const;
  void set_type(::waymo::open_dataset::RoadLine_RoadLineType value);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.RoadLine)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint > polyline_;
  int type_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class StopSign :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.StopSign) */ {
 public:
  StopSign();
  virtual ~StopSign();

  StopSign(const StopSign& from);
  StopSign(StopSign&& from) noexcept
    : StopSign() {
    *this = ::std::move(from);
  }

  inline StopSign& operator=(const StopSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSign& operator=(StopSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopSign* internal_default_instance() {
    return reinterpret_cast<const StopSign*>(
               &_StopSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StopSign& a, StopSign& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSign* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopSign* New() const final {
    return CreateMaybeMessage<StopSign>(nullptr);
  }

  StopSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopSign>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopSign& from);
  void MergeFrom(const StopSign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.StopSign";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // repeated int64 lane = 1;
  int lane_size() const;
  void clear_lane();
  ::PROTOBUF_NAMESPACE_ID::int64 lane(int index) const;
  void set_lane(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_lane(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      lane() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_lane();

  // optional .waymo.open_dataset.MapPoint position = 2;
  bool has_position() const;
  void clear_position();
  const ::waymo::open_dataset::MapPoint& position() const;
  ::waymo::open_dataset::MapPoint* release_position();
  ::waymo::open_dataset::MapPoint* mutable_position();
  void set_allocated_position(::waymo::open_dataset::MapPoint* position);

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.StopSign)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > lane_;
  ::waymo::open_dataset::MapPoint* position_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class Crosswalk :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.Crosswalk) */ {
 public:
  Crosswalk();
  virtual ~Crosswalk();

  Crosswalk(const Crosswalk& from);
  Crosswalk(Crosswalk&& from) noexcept
    : Crosswalk() {
    *this = ::std::move(from);
  }

  inline Crosswalk& operator=(const Crosswalk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Crosswalk& operator=(Crosswalk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Crosswalk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Crosswalk* internal_default_instance() {
    return reinterpret_cast<const Crosswalk*>(
               &_Crosswalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Crosswalk& a, Crosswalk& b) {
    a.Swap(&b);
  }
  inline void Swap(Crosswalk* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Crosswalk* New() const final {
    return CreateMaybeMessage<Crosswalk>(nullptr);
  }

  Crosswalk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Crosswalk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Crosswalk& from);
  void MergeFrom(const Crosswalk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Crosswalk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.Crosswalk";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 1,
  };
  // repeated .waymo.open_dataset.MapPoint polygon = 1;
  int polygon_size() const;
  void clear_polygon();
  ::waymo::open_dataset::MapPoint* mutable_polygon(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
      mutable_polygon();
  const ::waymo::open_dataset::MapPoint& polygon(int index) const;
  ::waymo::open_dataset::MapPoint* add_polygon();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
      polygon() const;

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.Crosswalk)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint > polygon_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// -------------------------------------------------------------------

class SpeedBump :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:waymo.open_dataset.SpeedBump) */ {
 public:
  SpeedBump();
  virtual ~SpeedBump();

  SpeedBump(const SpeedBump& from);
  SpeedBump(SpeedBump&& from) noexcept
    : SpeedBump() {
    *this = ::std::move(from);
  }

  inline SpeedBump& operator=(const SpeedBump& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedBump& operator=(SpeedBump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedBump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedBump* internal_default_instance() {
    return reinterpret_cast<const SpeedBump*>(
               &_SpeedBump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SpeedBump& a, SpeedBump& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedBump* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedBump* New() const final {
    return CreateMaybeMessage<SpeedBump>(nullptr);
  }

  SpeedBump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedBump>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedBump& from);
  void MergeFrom(const SpeedBump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedBump* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "waymo.open_dataset.SpeedBump";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto);
    return ::descriptor_table_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 1,
  };
  // repeated .waymo.open_dataset.MapPoint polygon = 1;
  int polygon_size() const;
  void clear_polygon();
  ::waymo::open_dataset::MapPoint* mutable_polygon(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
      mutable_polygon();
  const ::waymo::open_dataset::MapPoint& polygon(int index) const;
  ::waymo::open_dataset::MapPoint* add_polygon();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
      polygon() const;

  // @@protoc_insertion_point(class_scope:waymo.open_dataset.SpeedBump)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint > polygon_;
  friend struct ::TableStruct_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Map

// repeated .waymo.open_dataset.MapFeature map_features = 1;
inline int Map::map_features_size() const {
  return map_features_.size();
}
inline void Map::clear_map_features() {
  map_features_.Clear();
}
inline ::waymo::open_dataset::MapFeature* Map::mutable_map_features(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.Map.map_features)
  return map_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapFeature >*
Map::mutable_map_features() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.Map.map_features)
  return &map_features_;
}
inline const ::waymo::open_dataset::MapFeature& Map::map_features(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.Map.map_features)
  return map_features_.Get(index);
}
inline ::waymo::open_dataset::MapFeature* Map::add_map_features() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.Map.map_features)
  return map_features_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapFeature >&
Map::map_features() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.Map.map_features)
  return map_features_;
}

// repeated .waymo.open_dataset.DynamicState dynamic_states = 2;
inline int Map::dynamic_states_size() const {
  return dynamic_states_.size();
}
inline void Map::clear_dynamic_states() {
  dynamic_states_.Clear();
}
inline ::waymo::open_dataset::DynamicState* Map::mutable_dynamic_states(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.Map.dynamic_states)
  return dynamic_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::DynamicState >*
Map::mutable_dynamic_states() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.Map.dynamic_states)
  return &dynamic_states_;
}
inline const ::waymo::open_dataset::DynamicState& Map::dynamic_states(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.Map.dynamic_states)
  return dynamic_states_.Get(index);
}
inline ::waymo::open_dataset::DynamicState* Map::add_dynamic_states() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.Map.dynamic_states)
  return dynamic_states_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::DynamicState >&
Map::dynamic_states() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.Map.dynamic_states)
  return dynamic_states_;
}

// -------------------------------------------------------------------

// DynamicState

// optional double timestamp_seconds = 1;
inline bool DynamicState::has_timestamp_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicState::clear_timestamp_seconds() {
  timestamp_seconds_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DynamicState::timestamp_seconds() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.DynamicState.timestamp_seconds)
  return timestamp_seconds_;
}
inline void DynamicState::set_timestamp_seconds(double value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_seconds_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.DynamicState.timestamp_seconds)
}

// repeated .waymo.open_dataset.TrafficSignalLaneState lane_states = 2;
inline int DynamicState::lane_states_size() const {
  return lane_states_.size();
}
inline void DynamicState::clear_lane_states() {
  lane_states_.Clear();
}
inline ::waymo::open_dataset::TrafficSignalLaneState* DynamicState::mutable_lane_states(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.DynamicState.lane_states)
  return lane_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::TrafficSignalLaneState >*
DynamicState::mutable_lane_states() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.DynamicState.lane_states)
  return &lane_states_;
}
inline const ::waymo::open_dataset::TrafficSignalLaneState& DynamicState::lane_states(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.DynamicState.lane_states)
  return lane_states_.Get(index);
}
inline ::waymo::open_dataset::TrafficSignalLaneState* DynamicState::add_lane_states() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.DynamicState.lane_states)
  return lane_states_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::TrafficSignalLaneState >&
DynamicState::lane_states() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.DynamicState.lane_states)
  return lane_states_;
}

// -------------------------------------------------------------------

// TrafficSignalLaneState

// optional int64 lane = 1;
inline bool TrafficSignalLaneState::has_lane() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficSignalLaneState::clear_lane() {
  lane_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TrafficSignalLaneState::lane() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.TrafficSignalLaneState.lane)
  return lane_;
}
inline void TrafficSignalLaneState::set_lane(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  lane_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.TrafficSignalLaneState.lane)
}

// optional .waymo.open_dataset.TrafficSignalLaneState.State state = 2;
inline bool TrafficSignalLaneState::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficSignalLaneState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::waymo::open_dataset::TrafficSignalLaneState_State TrafficSignalLaneState::state() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.TrafficSignalLaneState.state)
  return static_cast< ::waymo::open_dataset::TrafficSignalLaneState_State >(state_);
}
inline void TrafficSignalLaneState::set_state(::waymo::open_dataset::TrafficSignalLaneState_State value) {
  assert(::waymo::open_dataset::TrafficSignalLaneState_State_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.TrafficSignalLaneState.state)
}

// optional .waymo.open_dataset.MapPoint stop_point = 3;
inline bool TrafficSignalLaneState::has_stop_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficSignalLaneState::clear_stop_point() {
  if (stop_point_ != nullptr) stop_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::waymo::open_dataset::MapPoint& TrafficSignalLaneState::stop_point() const {
  const ::waymo::open_dataset::MapPoint* p = stop_point_;
  // @@protoc_insertion_point(field_get:waymo.open_dataset.TrafficSignalLaneState.stop_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::waymo::open_dataset::MapPoint*>(
      &::waymo::open_dataset::_MapPoint_default_instance_);
}
inline ::waymo::open_dataset::MapPoint* TrafficSignalLaneState::release_stop_point() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.TrafficSignalLaneState.stop_point)
  _has_bits_[0] &= ~0x00000001u;
  ::waymo::open_dataset::MapPoint* temp = stop_point_;
  stop_point_ = nullptr;
  return temp;
}
inline ::waymo::open_dataset::MapPoint* TrafficSignalLaneState::mutable_stop_point() {
  _has_bits_[0] |= 0x00000001u;
  if (stop_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::waymo::open_dataset::MapPoint>(GetArenaNoVirtual());
    stop_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.TrafficSignalLaneState.stop_point)
  return stop_point_;
}
inline void TrafficSignalLaneState::set_allocated_stop_point(::waymo::open_dataset::MapPoint* stop_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stop_point_;
  }
  if (stop_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stop_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stop_point_ = stop_point;
  // @@protoc_insertion_point(field_set_allocated:waymo.open_dataset.TrafficSignalLaneState.stop_point)
}

// -------------------------------------------------------------------

// MapFeature

// optional int64 id = 1;
inline bool MapFeature::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapFeature::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MapFeature::id() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapFeature.id)
  return id_;
}
inline void MapFeature::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.MapFeature.id)
}

// optional .waymo.open_dataset.LaneCenter lane = 3;
inline bool MapFeature::has_lane() const {
  return feature_data_case() == kLane;
}
inline void MapFeature::set_has_lane() {
  _oneof_case_[0] = kLane;
}
inline void MapFeature::clear_lane() {
  if (has_lane()) {
    delete feature_data_.lane_;
    clear_has_feature_data();
  }
}
inline ::waymo::open_dataset::LaneCenter* MapFeature::release_lane() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.MapFeature.lane)
  if (has_lane()) {
    clear_has_feature_data();
      ::waymo::open_dataset::LaneCenter* temp = feature_data_.lane_;
    feature_data_.lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::waymo::open_dataset::LaneCenter& MapFeature::lane() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapFeature.lane)
  return has_lane()
      ? *feature_data_.lane_
      : *reinterpret_cast< ::waymo::open_dataset::LaneCenter*>(&::waymo::open_dataset::_LaneCenter_default_instance_);
}
inline ::waymo::open_dataset::LaneCenter* MapFeature::mutable_lane() {
  if (!has_lane()) {
    clear_feature_data();
    set_has_lane();
    feature_data_.lane_ = CreateMaybeMessage< ::waymo::open_dataset::LaneCenter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.MapFeature.lane)
  return feature_data_.lane_;
}

// optional .waymo.open_dataset.RoadLine road_line = 4;
inline bool MapFeature::has_road_line() const {
  return feature_data_case() == kRoadLine;
}
inline void MapFeature::set_has_road_line() {
  _oneof_case_[0] = kRoadLine;
}
inline void MapFeature::clear_road_line() {
  if (has_road_line()) {
    delete feature_data_.road_line_;
    clear_has_feature_data();
  }
}
inline ::waymo::open_dataset::RoadLine* MapFeature::release_road_line() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.MapFeature.road_line)
  if (has_road_line()) {
    clear_has_feature_data();
      ::waymo::open_dataset::RoadLine* temp = feature_data_.road_line_;
    feature_data_.road_line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::waymo::open_dataset::RoadLine& MapFeature::road_line() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapFeature.road_line)
  return has_road_line()
      ? *feature_data_.road_line_
      : *reinterpret_cast< ::waymo::open_dataset::RoadLine*>(&::waymo::open_dataset::_RoadLine_default_instance_);
}
inline ::waymo::open_dataset::RoadLine* MapFeature::mutable_road_line() {
  if (!has_road_line()) {
    clear_feature_data();
    set_has_road_line();
    feature_data_.road_line_ = CreateMaybeMessage< ::waymo::open_dataset::RoadLine >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.MapFeature.road_line)
  return feature_data_.road_line_;
}

// optional .waymo.open_dataset.RoadEdge road_edge = 5;
inline bool MapFeature::has_road_edge() const {
  return feature_data_case() == kRoadEdge;
}
inline void MapFeature::set_has_road_edge() {
  _oneof_case_[0] = kRoadEdge;
}
inline void MapFeature::clear_road_edge() {
  if (has_road_edge()) {
    delete feature_data_.road_edge_;
    clear_has_feature_data();
  }
}
inline ::waymo::open_dataset::RoadEdge* MapFeature::release_road_edge() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.MapFeature.road_edge)
  if (has_road_edge()) {
    clear_has_feature_data();
      ::waymo::open_dataset::RoadEdge* temp = feature_data_.road_edge_;
    feature_data_.road_edge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::waymo::open_dataset::RoadEdge& MapFeature::road_edge() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapFeature.road_edge)
  return has_road_edge()
      ? *feature_data_.road_edge_
      : *reinterpret_cast< ::waymo::open_dataset::RoadEdge*>(&::waymo::open_dataset::_RoadEdge_default_instance_);
}
inline ::waymo::open_dataset::RoadEdge* MapFeature::mutable_road_edge() {
  if (!has_road_edge()) {
    clear_feature_data();
    set_has_road_edge();
    feature_data_.road_edge_ = CreateMaybeMessage< ::waymo::open_dataset::RoadEdge >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.MapFeature.road_edge)
  return feature_data_.road_edge_;
}

// optional .waymo.open_dataset.StopSign stop_sign = 7;
inline bool MapFeature::has_stop_sign() const {
  return feature_data_case() == kStopSign;
}
inline void MapFeature::set_has_stop_sign() {
  _oneof_case_[0] = kStopSign;
}
inline void MapFeature::clear_stop_sign() {
  if (has_stop_sign()) {
    delete feature_data_.stop_sign_;
    clear_has_feature_data();
  }
}
inline ::waymo::open_dataset::StopSign* MapFeature::release_stop_sign() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.MapFeature.stop_sign)
  if (has_stop_sign()) {
    clear_has_feature_data();
      ::waymo::open_dataset::StopSign* temp = feature_data_.stop_sign_;
    feature_data_.stop_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::waymo::open_dataset::StopSign& MapFeature::stop_sign() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapFeature.stop_sign)
  return has_stop_sign()
      ? *feature_data_.stop_sign_
      : *reinterpret_cast< ::waymo::open_dataset::StopSign*>(&::waymo::open_dataset::_StopSign_default_instance_);
}
inline ::waymo::open_dataset::StopSign* MapFeature::mutable_stop_sign() {
  if (!has_stop_sign()) {
    clear_feature_data();
    set_has_stop_sign();
    feature_data_.stop_sign_ = CreateMaybeMessage< ::waymo::open_dataset::StopSign >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.MapFeature.stop_sign)
  return feature_data_.stop_sign_;
}

// optional .waymo.open_dataset.Crosswalk crosswalk = 8;
inline bool MapFeature::has_crosswalk() const {
  return feature_data_case() == kCrosswalk;
}
inline void MapFeature::set_has_crosswalk() {
  _oneof_case_[0] = kCrosswalk;
}
inline void MapFeature::clear_crosswalk() {
  if (has_crosswalk()) {
    delete feature_data_.crosswalk_;
    clear_has_feature_data();
  }
}
inline ::waymo::open_dataset::Crosswalk* MapFeature::release_crosswalk() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.MapFeature.crosswalk)
  if (has_crosswalk()) {
    clear_has_feature_data();
      ::waymo::open_dataset::Crosswalk* temp = feature_data_.crosswalk_;
    feature_data_.crosswalk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::waymo::open_dataset::Crosswalk& MapFeature::crosswalk() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapFeature.crosswalk)
  return has_crosswalk()
      ? *feature_data_.crosswalk_
      : *reinterpret_cast< ::waymo::open_dataset::Crosswalk*>(&::waymo::open_dataset::_Crosswalk_default_instance_);
}
inline ::waymo::open_dataset::Crosswalk* MapFeature::mutable_crosswalk() {
  if (!has_crosswalk()) {
    clear_feature_data();
    set_has_crosswalk();
    feature_data_.crosswalk_ = CreateMaybeMessage< ::waymo::open_dataset::Crosswalk >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.MapFeature.crosswalk)
  return feature_data_.crosswalk_;
}

// optional .waymo.open_dataset.SpeedBump speed_bump = 9;
inline bool MapFeature::has_speed_bump() const {
  return feature_data_case() == kSpeedBump;
}
inline void MapFeature::set_has_speed_bump() {
  _oneof_case_[0] = kSpeedBump;
}
inline void MapFeature::clear_speed_bump() {
  if (has_speed_bump()) {
    delete feature_data_.speed_bump_;
    clear_has_feature_data();
  }
}
inline ::waymo::open_dataset::SpeedBump* MapFeature::release_speed_bump() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.MapFeature.speed_bump)
  if (has_speed_bump()) {
    clear_has_feature_data();
      ::waymo::open_dataset::SpeedBump* temp = feature_data_.speed_bump_;
    feature_data_.speed_bump_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::waymo::open_dataset::SpeedBump& MapFeature::speed_bump() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapFeature.speed_bump)
  return has_speed_bump()
      ? *feature_data_.speed_bump_
      : *reinterpret_cast< ::waymo::open_dataset::SpeedBump*>(&::waymo::open_dataset::_SpeedBump_default_instance_);
}
inline ::waymo::open_dataset::SpeedBump* MapFeature::mutable_speed_bump() {
  if (!has_speed_bump()) {
    clear_feature_data();
    set_has_speed_bump();
    feature_data_.speed_bump_ = CreateMaybeMessage< ::waymo::open_dataset::SpeedBump >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.MapFeature.speed_bump)
  return feature_data_.speed_bump_;
}

inline bool MapFeature::has_feature_data() const {
  return feature_data_case() != FEATURE_DATA_NOT_SET;
}
inline void MapFeature::clear_has_feature_data() {
  _oneof_case_[0] = FEATURE_DATA_NOT_SET;
}
inline MapFeature::FeatureDataCase MapFeature::feature_data_case() const {
  return MapFeature::FeatureDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MapPoint

// optional double x = 1;
inline bool MapPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPoint::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double MapPoint::x() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapPoint.x)
  return x_;
}
inline void MapPoint::set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.MapPoint.x)
}

// optional double y = 2;
inline bool MapPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPoint::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double MapPoint::y() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapPoint.y)
  return y_;
}
inline void MapPoint::set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.MapPoint.y)
}

// optional double z = 3;
inline bool MapPoint::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapPoint::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double MapPoint::z() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.MapPoint.z)
  return z_;
}
inline void MapPoint::set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.MapPoint.z)
}

// -------------------------------------------------------------------

// BoundarySegment

// optional int32 lane_start_index = 1;
inline bool BoundarySegment::has_lane_start_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundarySegment::clear_lane_start_index() {
  lane_start_index_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoundarySegment::lane_start_index() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.BoundarySegment.lane_start_index)
  return lane_start_index_;
}
inline void BoundarySegment::set_lane_start_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  lane_start_index_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.BoundarySegment.lane_start_index)
}

// optional int32 lane_end_index = 2;
inline bool BoundarySegment::has_lane_end_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundarySegment::clear_lane_end_index() {
  lane_end_index_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoundarySegment::lane_end_index() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.BoundarySegment.lane_end_index)
  return lane_end_index_;
}
inline void BoundarySegment::set_lane_end_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  lane_end_index_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.BoundarySegment.lane_end_index)
}

// optional int64 boundary_feature_id = 3;
inline bool BoundarySegment::has_boundary_feature_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoundarySegment::clear_boundary_feature_id() {
  boundary_feature_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BoundarySegment::boundary_feature_id() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.BoundarySegment.boundary_feature_id)
  return boundary_feature_id_;
}
inline void BoundarySegment::set_boundary_feature_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  boundary_feature_id_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.BoundarySegment.boundary_feature_id)
}

// optional .waymo.open_dataset.RoadLine.RoadLineType boundary_type = 4;
inline bool BoundarySegment::has_boundary_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoundarySegment::clear_boundary_type() {
  boundary_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::waymo::open_dataset::RoadLine_RoadLineType BoundarySegment::boundary_type() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.BoundarySegment.boundary_type)
  return static_cast< ::waymo::open_dataset::RoadLine_RoadLineType >(boundary_type_);
}
inline void BoundarySegment::set_boundary_type(::waymo::open_dataset::RoadLine_RoadLineType value) {
  assert(::waymo::open_dataset::RoadLine_RoadLineType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  boundary_type_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.BoundarySegment.boundary_type)
}

// -------------------------------------------------------------------

// LaneNeighbor

// optional int64 feature_id = 1;
inline bool LaneNeighbor::has_feature_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneNeighbor::clear_feature_id() {
  feature_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LaneNeighbor::feature_id() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneNeighbor.feature_id)
  return feature_id_;
}
inline void LaneNeighbor::set_feature_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  feature_id_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneNeighbor.feature_id)
}

// optional int32 self_start_index = 2;
inline bool LaneNeighbor::has_self_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneNeighbor::clear_self_start_index() {
  self_start_index_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneNeighbor::self_start_index() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneNeighbor.self_start_index)
  return self_start_index_;
}
inline void LaneNeighbor::set_self_start_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  self_start_index_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneNeighbor.self_start_index)
}

// optional int32 self_end_index = 3;
inline bool LaneNeighbor::has_self_end_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneNeighbor::clear_self_end_index() {
  self_end_index_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneNeighbor::self_end_index() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneNeighbor.self_end_index)
  return self_end_index_;
}
inline void LaneNeighbor::set_self_end_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  self_end_index_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneNeighbor.self_end_index)
}

// optional int32 neighbor_start_index = 4;
inline bool LaneNeighbor::has_neighbor_start_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneNeighbor::clear_neighbor_start_index() {
  neighbor_start_index_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneNeighbor::neighbor_start_index() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneNeighbor.neighbor_start_index)
  return neighbor_start_index_;
}
inline void LaneNeighbor::set_neighbor_start_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  neighbor_start_index_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneNeighbor.neighbor_start_index)
}

// optional int32 neighbor_end_index = 5;
inline bool LaneNeighbor::has_neighbor_end_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneNeighbor::clear_neighbor_end_index() {
  neighbor_end_index_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LaneNeighbor::neighbor_end_index() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneNeighbor.neighbor_end_index)
  return neighbor_end_index_;
}
inline void LaneNeighbor::set_neighbor_end_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  neighbor_end_index_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneNeighbor.neighbor_end_index)
}

// repeated .waymo.open_dataset.BoundarySegment boundaries = 6;
inline int LaneNeighbor::boundaries_size() const {
  return boundaries_.size();
}
inline void LaneNeighbor::clear_boundaries() {
  boundaries_.Clear();
}
inline ::waymo::open_dataset::BoundarySegment* LaneNeighbor::mutable_boundaries(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.LaneNeighbor.boundaries)
  return boundaries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >*
LaneNeighbor::mutable_boundaries() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneNeighbor.boundaries)
  return &boundaries_;
}
inline const ::waymo::open_dataset::BoundarySegment& LaneNeighbor::boundaries(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneNeighbor.boundaries)
  return boundaries_.Get(index);
}
inline ::waymo::open_dataset::BoundarySegment* LaneNeighbor::add_boundaries() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneNeighbor.boundaries)
  return boundaries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >&
LaneNeighbor::boundaries() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneNeighbor.boundaries)
  return boundaries_;
}

// -------------------------------------------------------------------

// LaneCenter

// optional double speed_limit_mph = 1;
inline bool LaneCenter::has_speed_limit_mph() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneCenter::clear_speed_limit_mph() {
  speed_limit_mph_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LaneCenter::speed_limit_mph() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.speed_limit_mph)
  return speed_limit_mph_;
}
inline void LaneCenter::set_speed_limit_mph(double value) {
  _has_bits_[0] |= 0x00000001u;
  speed_limit_mph_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneCenter.speed_limit_mph)
}

// optional .waymo.open_dataset.LaneCenter.LaneType type = 2;
inline bool LaneCenter::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneCenter::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::waymo::open_dataset::LaneCenter_LaneType LaneCenter::type() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.type)
  return static_cast< ::waymo::open_dataset::LaneCenter_LaneType >(type_);
}
inline void LaneCenter::set_type(::waymo::open_dataset::LaneCenter_LaneType value) {
  assert(::waymo::open_dataset::LaneCenter_LaneType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneCenter.type)
}

// optional bool interpolating = 3;
inline bool LaneCenter::has_interpolating() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneCenter::clear_interpolating() {
  interpolating_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool LaneCenter::interpolating() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.interpolating)
  return interpolating_;
}
inline void LaneCenter::set_interpolating(bool value) {
  _has_bits_[0] |= 0x00000004u;
  interpolating_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneCenter.interpolating)
}

// repeated .waymo.open_dataset.MapPoint polyline = 8;
inline int LaneCenter::polyline_size() const {
  return polyline_.size();
}
inline void LaneCenter::clear_polyline() {
  polyline_.Clear();
}
inline ::waymo::open_dataset::MapPoint* LaneCenter::mutable_polyline(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.LaneCenter.polyline)
  return polyline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
LaneCenter::mutable_polyline() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneCenter.polyline)
  return &polyline_;
}
inline const ::waymo::open_dataset::MapPoint& LaneCenter::polyline(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.polyline)
  return polyline_.Get(index);
}
inline ::waymo::open_dataset::MapPoint* LaneCenter::add_polyline() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneCenter.polyline)
  return polyline_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
LaneCenter::polyline() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneCenter.polyline)
  return polyline_;
}

// repeated int64 entry_lanes = 9 [packed = true];
inline int LaneCenter::entry_lanes_size() const {
  return entry_lanes_.size();
}
inline void LaneCenter::clear_entry_lanes() {
  entry_lanes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LaneCenter::entry_lanes(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.entry_lanes)
  return entry_lanes_.Get(index);
}
inline void LaneCenter::set_entry_lanes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  entry_lanes_.Set(index, value);
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneCenter.entry_lanes)
}
inline void LaneCenter::add_entry_lanes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  entry_lanes_.Add(value);
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneCenter.entry_lanes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LaneCenter::entry_lanes() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneCenter.entry_lanes)
  return entry_lanes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LaneCenter::mutable_entry_lanes() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneCenter.entry_lanes)
  return &entry_lanes_;
}

// repeated int64 exit_lanes = 10 [packed = true];
inline int LaneCenter::exit_lanes_size() const {
  return exit_lanes_.size();
}
inline void LaneCenter::clear_exit_lanes() {
  exit_lanes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LaneCenter::exit_lanes(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.exit_lanes)
  return exit_lanes_.Get(index);
}
inline void LaneCenter::set_exit_lanes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  exit_lanes_.Set(index, value);
  // @@protoc_insertion_point(field_set:waymo.open_dataset.LaneCenter.exit_lanes)
}
inline void LaneCenter::add_exit_lanes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  exit_lanes_.Add(value);
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneCenter.exit_lanes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LaneCenter::exit_lanes() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneCenter.exit_lanes)
  return exit_lanes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LaneCenter::mutable_exit_lanes() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneCenter.exit_lanes)
  return &exit_lanes_;
}

// repeated .waymo.open_dataset.BoundarySegment left_boundaries = 13;
inline int LaneCenter::left_boundaries_size() const {
  return left_boundaries_.size();
}
inline void LaneCenter::clear_left_boundaries() {
  left_boundaries_.Clear();
}
inline ::waymo::open_dataset::BoundarySegment* LaneCenter::mutable_left_boundaries(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.LaneCenter.left_boundaries)
  return left_boundaries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >*
LaneCenter::mutable_left_boundaries() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneCenter.left_boundaries)
  return &left_boundaries_;
}
inline const ::waymo::open_dataset::BoundarySegment& LaneCenter::left_boundaries(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.left_boundaries)
  return left_boundaries_.Get(index);
}
inline ::waymo::open_dataset::BoundarySegment* LaneCenter::add_left_boundaries() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneCenter.left_boundaries)
  return left_boundaries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >&
LaneCenter::left_boundaries() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneCenter.left_boundaries)
  return left_boundaries_;
}

// repeated .waymo.open_dataset.BoundarySegment right_boundaries = 14;
inline int LaneCenter::right_boundaries_size() const {
  return right_boundaries_.size();
}
inline void LaneCenter::clear_right_boundaries() {
  right_boundaries_.Clear();
}
inline ::waymo::open_dataset::BoundarySegment* LaneCenter::mutable_right_boundaries(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.LaneCenter.right_boundaries)
  return right_boundaries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >*
LaneCenter::mutable_right_boundaries() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneCenter.right_boundaries)
  return &right_boundaries_;
}
inline const ::waymo::open_dataset::BoundarySegment& LaneCenter::right_boundaries(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.right_boundaries)
  return right_boundaries_.Get(index);
}
inline ::waymo::open_dataset::BoundarySegment* LaneCenter::add_right_boundaries() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneCenter.right_boundaries)
  return right_boundaries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::BoundarySegment >&
LaneCenter::right_boundaries() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneCenter.right_boundaries)
  return right_boundaries_;
}

// repeated .waymo.open_dataset.LaneNeighbor left_neighbors = 11;
inline int LaneCenter::left_neighbors_size() const {
  return left_neighbors_.size();
}
inline void LaneCenter::clear_left_neighbors() {
  left_neighbors_.Clear();
}
inline ::waymo::open_dataset::LaneNeighbor* LaneCenter::mutable_left_neighbors(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.LaneCenter.left_neighbors)
  return left_neighbors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >*
LaneCenter::mutable_left_neighbors() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneCenter.left_neighbors)
  return &left_neighbors_;
}
inline const ::waymo::open_dataset::LaneNeighbor& LaneCenter::left_neighbors(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.left_neighbors)
  return left_neighbors_.Get(index);
}
inline ::waymo::open_dataset::LaneNeighbor* LaneCenter::add_left_neighbors() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneCenter.left_neighbors)
  return left_neighbors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >&
LaneCenter::left_neighbors() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneCenter.left_neighbors)
  return left_neighbors_;
}

// repeated .waymo.open_dataset.LaneNeighbor right_neighbors = 12;
inline int LaneCenter::right_neighbors_size() const {
  return right_neighbors_.size();
}
inline void LaneCenter::clear_right_neighbors() {
  right_neighbors_.Clear();
}
inline ::waymo::open_dataset::LaneNeighbor* LaneCenter::mutable_right_neighbors(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.LaneCenter.right_neighbors)
  return right_neighbors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >*
LaneCenter::mutable_right_neighbors() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.LaneCenter.right_neighbors)
  return &right_neighbors_;
}
inline const ::waymo::open_dataset::LaneNeighbor& LaneCenter::right_neighbors(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.LaneCenter.right_neighbors)
  return right_neighbors_.Get(index);
}
inline ::waymo::open_dataset::LaneNeighbor* LaneCenter::add_right_neighbors() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.LaneCenter.right_neighbors)
  return right_neighbors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::LaneNeighbor >&
LaneCenter::right_neighbors() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.LaneCenter.right_neighbors)
  return right_neighbors_;
}

// -------------------------------------------------------------------

// RoadEdge

// optional .waymo.open_dataset.RoadEdge.RoadEdgeType type = 1;
inline bool RoadEdge::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadEdge::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::waymo::open_dataset::RoadEdge_RoadEdgeType RoadEdge::type() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.RoadEdge.type)
  return static_cast< ::waymo::open_dataset::RoadEdge_RoadEdgeType >(type_);
}
inline void RoadEdge::set_type(::waymo::open_dataset::RoadEdge_RoadEdgeType value) {
  assert(::waymo::open_dataset::RoadEdge_RoadEdgeType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.RoadEdge.type)
}

// repeated .waymo.open_dataset.MapPoint polyline = 2;
inline int RoadEdge::polyline_size() const {
  return polyline_.size();
}
inline void RoadEdge::clear_polyline() {
  polyline_.Clear();
}
inline ::waymo::open_dataset::MapPoint* RoadEdge::mutable_polyline(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.RoadEdge.polyline)
  return polyline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
RoadEdge::mutable_polyline() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.RoadEdge.polyline)
  return &polyline_;
}
inline const ::waymo::open_dataset::MapPoint& RoadEdge::polyline(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.RoadEdge.polyline)
  return polyline_.Get(index);
}
inline ::waymo::open_dataset::MapPoint* RoadEdge::add_polyline() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.RoadEdge.polyline)
  return polyline_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
RoadEdge::polyline() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.RoadEdge.polyline)
  return polyline_;
}

// -------------------------------------------------------------------

// RoadLine

// optional .waymo.open_dataset.RoadLine.RoadLineType type = 1;
inline bool RoadLine::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadLine::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::waymo::open_dataset::RoadLine_RoadLineType RoadLine::type() const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.RoadLine.type)
  return static_cast< ::waymo::open_dataset::RoadLine_RoadLineType >(type_);
}
inline void RoadLine::set_type(::waymo::open_dataset::RoadLine_RoadLineType value) {
  assert(::waymo::open_dataset::RoadLine_RoadLineType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:waymo.open_dataset.RoadLine.type)
}

// repeated .waymo.open_dataset.MapPoint polyline = 2;
inline int RoadLine::polyline_size() const {
  return polyline_.size();
}
inline void RoadLine::clear_polyline() {
  polyline_.Clear();
}
inline ::waymo::open_dataset::MapPoint* RoadLine::mutable_polyline(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.RoadLine.polyline)
  return polyline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
RoadLine::mutable_polyline() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.RoadLine.polyline)
  return &polyline_;
}
inline const ::waymo::open_dataset::MapPoint& RoadLine::polyline(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.RoadLine.polyline)
  return polyline_.Get(index);
}
inline ::waymo::open_dataset::MapPoint* RoadLine::add_polyline() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.RoadLine.polyline)
  return polyline_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
RoadLine::polyline() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.RoadLine.polyline)
  return polyline_;
}

// -------------------------------------------------------------------

// StopSign

// repeated int64 lane = 1;
inline int StopSign::lane_size() const {
  return lane_.size();
}
inline void StopSign::clear_lane() {
  lane_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StopSign::lane(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.StopSign.lane)
  return lane_.Get(index);
}
inline void StopSign::set_lane(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  lane_.Set(index, value);
  // @@protoc_insertion_point(field_set:waymo.open_dataset.StopSign.lane)
}
inline void StopSign::add_lane(::PROTOBUF_NAMESPACE_ID::int64 value) {
  lane_.Add(value);
  // @@protoc_insertion_point(field_add:waymo.open_dataset.StopSign.lane)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StopSign::lane() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.StopSign.lane)
  return lane_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StopSign::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.StopSign.lane)
  return &lane_;
}

// optional .waymo.open_dataset.MapPoint position = 2;
inline bool StopSign::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSign::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::waymo::open_dataset::MapPoint& StopSign::position() const {
  const ::waymo::open_dataset::MapPoint* p = position_;
  // @@protoc_insertion_point(field_get:waymo.open_dataset.StopSign.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::waymo::open_dataset::MapPoint*>(
      &::waymo::open_dataset::_MapPoint_default_instance_);
}
inline ::waymo::open_dataset::MapPoint* StopSign::release_position() {
  // @@protoc_insertion_point(field_release:waymo.open_dataset.StopSign.position)
  _has_bits_[0] &= ~0x00000001u;
  ::waymo::open_dataset::MapPoint* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::waymo::open_dataset::MapPoint* StopSign::mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::waymo::open_dataset::MapPoint>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.StopSign.position)
  return position_;
}
inline void StopSign::set_allocated_position(::waymo::open_dataset::MapPoint* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:waymo.open_dataset.StopSign.position)
}

// -------------------------------------------------------------------

// Crosswalk

// repeated .waymo.open_dataset.MapPoint polygon = 1;
inline int Crosswalk::polygon_size() const {
  return polygon_.size();
}
inline void Crosswalk::clear_polygon() {
  polygon_.Clear();
}
inline ::waymo::open_dataset::MapPoint* Crosswalk::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.Crosswalk.polygon)
  return polygon_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
Crosswalk::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.Crosswalk.polygon)
  return &polygon_;
}
inline const ::waymo::open_dataset::MapPoint& Crosswalk::polygon(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.Crosswalk.polygon)
  return polygon_.Get(index);
}
inline ::waymo::open_dataset::MapPoint* Crosswalk::add_polygon() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.Crosswalk.polygon)
  return polygon_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
Crosswalk::polygon() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.Crosswalk.polygon)
  return polygon_;
}

// -------------------------------------------------------------------

// SpeedBump

// repeated .waymo.open_dataset.MapPoint polygon = 1;
inline int SpeedBump::polygon_size() const {
  return polygon_.size();
}
inline void SpeedBump::clear_polygon() {
  polygon_.Clear();
}
inline ::waymo::open_dataset::MapPoint* SpeedBump::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:waymo.open_dataset.SpeedBump.polygon)
  return polygon_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >*
SpeedBump::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:waymo.open_dataset.SpeedBump.polygon)
  return &polygon_;
}
inline const ::waymo::open_dataset::MapPoint& SpeedBump::polygon(int index) const {
  // @@protoc_insertion_point(field_get:waymo.open_dataset.SpeedBump.polygon)
  return polygon_.Get(index);
}
inline ::waymo::open_dataset::MapPoint* SpeedBump::add_polygon() {
  // @@protoc_insertion_point(field_add:waymo.open_dataset.SpeedBump.polygon)
  return polygon_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::waymo::open_dataset::MapPoint >&
SpeedBump::polygon() const {
  // @@protoc_insertion_point(field_list:waymo.open_dataset.SpeedBump.polygon)
  return polygon_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace open_dataset
}  // namespace waymo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::waymo::open_dataset::TrafficSignalLaneState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::waymo::open_dataset::TrafficSignalLaneState_State>() {
  return ::waymo::open_dataset::TrafficSignalLaneState_State_descriptor();
}
template <> struct is_proto_enum< ::waymo::open_dataset::LaneCenter_LaneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::waymo::open_dataset::LaneCenter_LaneType>() {
  return ::waymo::open_dataset::LaneCenter_LaneType_descriptor();
}
template <> struct is_proto_enum< ::waymo::open_dataset::RoadEdge_RoadEdgeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::waymo::open_dataset::RoadEdge_RoadEdgeType>() {
  return ::waymo::open_dataset::RoadEdge_RoadEdgeType_descriptor();
}
template <> struct is_proto_enum< ::waymo::open_dataset::RoadLine_RoadLineType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::waymo::open_dataset::RoadLine_RoadLineType>() {
  return ::waymo::open_dataset::RoadLine_RoadLineType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_waymo_5fopen_5fdataset_2fprotos_2fmap_2eproto
